#define DEBUG_MODE
#include "seudo_monitor.h"
static char* buffer;
static int curx,cury;
static struct termios orig_termios;
void disableRawMode(int fd){
	tcsetattr(fd,TCSAFLUSH,&orig_termios);
}
int enableRawMode(int fd, struct termios *orig){
	struct termios raw;
	tcgetattr(fd,orig);
	raw = *orig;
	raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
	raw.c_oflag &= ~(OPOST);
	raw.c_cflag |= (CS8);
	raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
	raw.c_cc[VMIN] = 0;
	raw.c_cc[VTIME] = 1;
	tcsetattr(fd,TCSAFLUSH, &raw);
}
void* keyboard_interrupt(void*);
void terminal_mode(){
	enableRawMode(STDOUT_FILENO,&orig_termios);
	
	// size
	struct winsize ws;
	ioctl(STDOUT_FILENO, TIOCGWINSZ,&ws);
	buffer = (char*)calloc(ws.ws_row*ws.ws_col*4,1);
	// cursor
	/*
	unsigned short curx=0, cury=0;
	write(STDOUT_FILENO, "\033[6n", 4);
	read(STDIN_FILENO, null,2);
	for(int i=0;i<100;i++){
		char c;
		read(STDIN_FILENO,&c,1);
		int r = c_to_i(c);
		if(r!=-1){
			curx = curx*10 + r;	
		}else if(c=='R') break;
		else if(c==';'){
			//printf("esc : %2d\n",i);	
			cury = curx;
			curx = 0;
		}//else debug_print("error\n");
	}
	//debug_print(curx);
	if(curx!=0) write(STDOUT_FILENO,"\r\n",2);
	//write(STDOUT_FILENO, '\e[31m',1);
	//debug_print(sizeof("\x1b[1;31m\u2588\u2588"));
	//
	*/
	//TODO: cursor init location save
	printf("%d\n",ws.ws_row);
	//printf("\033[2J");
	for(int i=0;i<ws.ws_row;i++){

		printf("\r\n");
		for(int j=0;j<ws.ws_col;j++){
			//write(STDOUT_FILENO, "\x1b[1;32m\u2588", 11);
			printf("\x1b[1;32m\u2588");
		}
	}
	pthread_t t2;
	pthread_create(&t2,NULL,keyboard_interrupt,NULL);
	while(1){
		sleep(1);
		printf("\033[2J");
		for(int i=0;i<ws.ws_row;i++){
			for(int j=0;j<ws.ws_col;j++){
				int color = 30;
				if(buffer[4*j]>128){
					color += 4;
				}
				if(buffer[4*j+1]>128){
					color += 2;
				}
				if(buffer[4*j+2]>128){
					color++;
				}
				if(buffer[4*j+3]>128){
					char* str = str_sum(str_sum("\x1b[1;",i_to_s(color)),"m\u2588");
					//write(STDOUT_FILENO,str, 11);
					printf(str);
				}
			}
			
			printf("\r\n");
		}	
		
		//printf("\033[1A\n");
		_message messages[1];
       		int message_size = clip(&messages,1);
		if(message_size) {
			char* bgra = messages[0].talk;
			bgra++;
			//buffer = bgra;	
			//printf("\033[2J");
			for(int i=0;i<ws.ws_row;i++){
				for(int j=0;j<ws.ws_col;j++){
					/*
					int color = 30;
					if(bgra[(i*ws.ws_col)+4*j]>128){
						color += 4;
					}
					if(bgra[(i*ws.ws_col)+4*j+1]>128){
						color += 2;
					}
					if(bgra[(i*ws.ws_col)+4*j+2]>128){
						color++;
					}
					*/
					if(bgra[(i*ws.ws_col)+4*j+3]>128){
					/*	char* str = str_sum(str_sum("\x1b[1;",i_to_s(color)),"m\u2588");
						//write(STDOUT_FILENO,str, 11);
						printf(str);
					}
					else{*/
						buffer[(i*ws.ws_col)+4*j] = bgra[(i*ws.ws_col)+4*j];
						buffer[(i*ws.ws_col)+4*j+1] = bgra[(i*ws.ws_col)+4*j+1];
						buffer[(i*ws.ws_col)+4*j+2] = bgra[(i*ws.ws_col)+4*j+2];
						buffer[(i*ws.ws_col)+4*j+3] = bgra[(i*ws.ws_col)+4*j+3];
					}

				}
				printf("\r\n");
			}	
		}
	}
}

void sighandler(int signum){
	printf("%d",signum);
	switch(signum){
		case SIGINT:
			exit(0);
		default:
			break;
	}
}

void* keyboard_interrupt(void* args){
	while(1){
		char c;
		read(STDIN_FILENO,&c,1);
		//TODO : cursor static variable value change, buffer value change
		switch(c){
			case 'q':
			case 'Q':
				printf("\033[2J\033[1A\n");
				disableRawMode(STDIN_FILENO);
				exit(0);
				break;
			case 's':
				printf("\033[2A\n");
				break;
			case 'x':
				printf("\033[1B\033[1A\n");
				break;
			case 'z':
				printf("\033[1D\033[1A\n");
				break;
			case 'c':
				printf("\033[1C\033[1A\n");
				break;
			case 'k':
				printf("\x1b[0;30m\u2588\033[1A\n");
				break;
			case 'l':
				printf("\x1b[0;31m\u2588\033[1A\n");
				break;
			case ';':
				printf("\x1b[0;32m\u2588\033[1A\n");
				break;
			case '\'':
				printf("\x1b[0;33m\u2588\033[1A\n");
				break;
			case 'm':
				printf("\x1b[0;34m\u2588\033[1A\n");
				break;
			case ',':
				printf("\x1b[0;35m\u2588\033[1A\n");
				break;
			case '.':
				printf("\x1b[0;36m\u2588\033[1A\n");
				break;
			case '/':
				printf("\x1b[0;37m\u2588\033[1A\n");
				break;
			case 'K':
				printf("\x1b[1;30m\u2588\033[1A\n");
				break;
			case 'L':
				printf("\x1b[1;31m\u2588\033[1A\n");
				break;
			case ':':
				printf("\x1b[1;32m\u2588\033[1A\n");
				break;
			case '\"':
				printf("\x1b[1;33m\u2588\033[1A\n");
				break;
			case 'M':
				printf("\x1b[1;34m\u2588\033[1A\n");
				break;
			case '<':
				printf("\x1b[1;35m\u2588\033[1A\n");
				break;
			case '>':
				printf("\x1b[1;36m\u2588\033[1A\n");
				break;
			case '?':
				printf("\x1b[1;37m\u2588\033[1A\n");
				break;
		}

	}
}

int main(int argc, char **argv){
       /* if(argc<2){
        printf("input file missed.\n");
        return 0;
        }
        char *contents = open_file(argv[1]);

        _parser parser;
        parser.index = 0;
        parser.prev_instruction = null;
        parse_instruction(contents,&parser);
	*/
        // void *memory = (void*)malloc(sizeof(_sci64)*1000);
        // bytecode_gen64(&parser,memory);
        //
        //signal(SIGINT,sighandler);
	init_file_comm("seudo_monitor",1);
        pthread_t t;
        pthread_create(&t,NULL,accept_friend,NULL);
	sleep(2);
	terminal_mode();

        return 0;
}

